' Gambas module file

' =====================================================
' FUNCIÓN: ExportarJATS
' DESCRIPCIÓN: EXPORTA REFERENCIAS BIBLIOGRÁFICAS A FORMATO XML-JATS
' RETORNA: Boolean - TRUE SI SE EXPORTÓ EXITOSAMENTE
' =====================================================

' =====================================================
' FUNCIÓN AUXILIAR: ConvertirTipoJATS
' DESCRIPCIÓN: CONVIERTE TIPO DE ENTRADA BIBTEX A TIPO JATS
' PARÁMETROS: sTipoBibTeX - TIPO DE ENTRADA BIBTEX
' RETORNA: String - TIPO DE PUBLICACIÓN JATS
' =====================================================

Private Function ConvertirTipoJATS(sTipoBibTeX As String) As String

  Dim mapeo As New Collection

  ' MAPEO DE TIPOS BIBTEX/BIBLATEX A JATS
  mapeo["article"] = "journal"
  mapeo["book"] = "book"
  mapeo["inbook"] = "book"
  mapeo["incollection"] = "book"
  mapeo["inproceedings"] = "confproc"
  mapeo["conference"] = "confproc"
  mapeo["proceedings"] = "confproc"
  mapeo["thesis"] = "thesis"
  mapeo["phdthesis"] = "thesis"
  mapeo["mastersthesis"] = "thesis"
  mapeo["techreport"] = "report"
  mapeo["manual"] = "report"
  mapeo["booklet"] = "book"
  mapeo["unpublished"] = "other"
  mapeo["misc"] = "other"
  mapeo["online"] = "web"
  mapeo["patent"] = "patent"
  mapeo["report"] = "report"
  mapeo["software"] = "software"
  mapeo["dataset"] = "dataset"

  If mapeo.Exist(Lower(sTipoBibTeX)) Then
    Return mapeo[Lower(sTipoBibTeX)]
  Else
    Return "other"
  Endif

End

' =====================================================
' FUNCIÓN AUXILIAR: GenerarPaginas
' DESCRIPCIÓN: GENERA ELEMENTOS <fpage> Y <lpage> DESDE CAMPO pages
' PARÁMETROS: sPages - STRING CON PÁGINAS (ej: "45-67" o "45--67")
' RETORNA: String - XML CON FPAGE Y LPAGE
' =====================================================

Private Function GenerarPaginas(sPages As String) As String

  Dim sXML As String
  Dim sPaginaInicio As String
  Dim sPaginaFin As String

  sXML = ""

  ' NORMALIZAR SEPARADORES DE PÁGINA
  sPages = Replace(sPages, "--", "-")

  If InStr(sPages, "-") > 0 Then
    ' HAY RANGO DE PÁGINAS
    sPaginaInicio = TrimUTF8(Split(sPages, "-")[0])
    sPaginaFin = TrimUTF8(Split(sPages, "-")[1])

    sXML &= "      <fpage>" & sPaginaInicio & "</fpage>\n"
    sXML &= "      <lpage>" & sPaginaFin & "</lpage>\n"
  Else
    ' SOLO UNA PÁGINA
    sXML &= "      <fpage>" & TrimUTF8(sPages) & "</fpage>\n"
  Endif

  Return sXML

End

' =====================================================
' FUNCIÓN AUXILIAR: EscaparXML
' DESCRIPCIÓN: ESCAPA CARACTERES ESPECIALES PARA XML
' PARÁMETROS: sTexto - TEXTO A ESCAPAR
' RETORNA: String - TEXTO ESCAPADO
' =====================================================

Private Function EscaparXML(sTexto As String) As String

  Dim sResultado As String

  sResultado = sTexto

  ' REEMPLAZAR CARACTERES ESPECIALES XML
  sResultado = Replace(sResultado, "&", "&amp;")
  sResultado = Replace(sResultado, "<", "&lt;")
  sResultado = Replace(sResultado, ">", "&gt;")
  sResultado = Replace(sResultado, "\"", "&quot;")
  sResultado = Replace(sResultado, "'", "&apos;")

  Return sResultado

End

' =====================================================
' FUNCIÓN AUXILIAR: ExtraerAnio
' DESCRIPCIÓN: EXTRAE EL AÑO DE UNA FECHA EN FORMATO ISO (YYYY-MM-DD)
' PARÁMETROS: sFecha - STRING CON FECHA
' RETORNA: String - AÑO EXTRAÍDO
' =====================================================

Private Function ExtraerAnio(sFecha As String) As String

  If InStr(sFecha, "-") > 0 Then
    ' FORMATO ISO: YYYY-MM-DD
    Return Split(sFecha, "-")[0]
  Else
    ' ASUMIR QUE ES SOLO EL AÑO
    Return sFecha
  Endif

End

' =====================================================
' FUNCIÓN AUXILIAR: ConvertirMarcaLatex
' DESCRIPCIÓN: CONVIERTE UNA MARCA LATEX {CONTENIDO} A MARCAS XML
' PARÁMETROS: sTexto - TEXTO COMPLETO
'             sMarcaLatex - MARCA LATEX (ej: "\\emph")
'             sMarcaApertura - MARCA XML APERTURA (ej: "<italic>")
'             sMarcaCierre - MARCA XML CIERRE (ej: "</italic>")
' RETORNA: String - TEXTO CON MARCAS CONVERTIDAS
' =====================================================

Private Function ConvertirMarcaLatex(sTexto As String, sMarcaLatex As String, sMarcaApertura As String, sMarcaCierre As String) As String

  Dim sResultado As String
  Dim posInicio As Integer
  Dim posFin As Integer
  Dim contenido As String

  sResultado = sTexto

  While InStr(sResultado, sMarcaLatex & "{") > 0
    posInicio = InStr(sResultado, sMarcaLatex & "{")

    ' PASAR LA POSICIÓN DESPUÉS DEL {
    posFin = EncontrarLlaveCorrespondiente(sResultado, posInicio + Len(sMarcaLatex) + 1)

    If posFin > 0 Then
      ' EXTRAER CONTENIDO ENTRE LLAVES
      contenido = Mid(sResultado, posInicio + Len(sMarcaLatex) + 1, posFin - posInicio - Len(sMarcaLatex) - 1)

      ' REEMPLAZAR CON MARCAS XML
      sResultado = Left(sResultado, posInicio - 1) & sMarcaApertura & contenido & sMarcaCierre & Mid(sResultado, posFin + 1)
    Else
      ' SI NO ENCUENTRA LLAVE DE CIERRE, SOLO QUITAR LA MARCA
      sResultado = Replace(sResultado, sMarcaLatex & "{", "", 1)
    Endif
  Wend

  Return sResultado

End

' =====================================================
' FUNCIÓN AUXILIAR: EncontrarLlaveCorrespondiente
' DESCRIPCIÓN: ENCUENTRA LA LLAVE DE CIERRE } CORRESPONDIENTE A UNA LLAVE DE APERTURA {
' PARÁMETROS: sTexto - TEXTO COMPLETO
'             iPosInicio - POSICIÓN DE LA LLAVE DE APERTURA {
' RETORNA: Integer - POSICIÓN DE LA LLAVE DE CIERRE, O -1 SI NO SE ENCUENTRA
' =====================================================

Private Function EncontrarLlaveCorrespondiente(sTexto As String, iPosInicio As Integer) As Integer

  Dim nivel As Integer = 1
  Dim i As Integer
  Dim caracter As String

  ' RECORRER DESDE LA POSICIÓN SIGUIENTE A LA LLAVE DE APERTURA
  For i = iPosInicio To Len(sTexto)
    caracter = Mid(sTexto, i, 1)

    If caracter = "{" Then
      nivel += 1
    Else If caracter = "}" Then
      nivel -= 1

      If nivel = 0 Then
        ' ENCONTRAMOS LA LLAVE CORRESPONDIENTE
        Return i
      Endif
    Endif
  Next

  ' NO SE ENCONTRÓ LLAVE DE CIERRE
  Return -1

End

' =====================================================
' FUNCIÓN: GenerarPersonGroup
' DESCRIPCIÓN: GENERA <person-group> DESDE STRING DE AUTORES BIBTEX
' PARÁMETROS:
'   sNombres: String con autores (Apellido, Nombre and Apellido2, Nombre2)
'   sTipo: Tipo de grupo (author, editor, translator)
' RETORNA: String XML con <person-group>
' =====================================================

Private Function GenerarPersonGroup(sNombres As String, sTipo As String) As String

  Dim sXML As String
  Dim aNombres As String[]
  Dim nombreCompleto As String
  Dim apellido As String
  Dim nombre As String
  Dim posComa As Integer
  Dim i As Integer

  sXML = "      <person-group person-group-type=\"" & sTipo & "\">\n"

  ' NORMALIZAR ESPACIOS (tabs, nbsp, dobles espacios)
  sNombres = Replace(sNombres, Chr(9), " ")    ' Tab
  sNombres = Replace(sNombres, Chr(160), " ")  ' Non-breaking space
  While InStr(sNombres, "  ")
    sNombres = Replace(sNombres, "  ", " ")
  Wend

  ' ============================================
  ' ⚠️ TRIM MANUAL: SOLO ESPACIOS ASCII (32)
  ' NO USAR Trim() QUE ELIMINA BYTES UTF-8
  ' ============================================
  sNombres = TrimUTF8(sNombres)

  ' TRUCO: REEMPLAZAR " and " POR UN MARCADOR ÚNICO
  sNombres = Replace(sNombres, " and ", "|||")

  ' DIVIDIR
  aNombres = Split(sNombres, "|||")

  ' PROCESAR CADA AUTOR
  For i = 0 To aNombres.Max
    nombreCompleto = TrimUTF8(aNombres[i])

    If Len(nombreCompleto) = 0 Then Continue

    ' VERIFICAR SI ES "others" (et al.)
    If nombreCompleto = "others" Or nombreCompleto = "et al" Or nombreCompleto = "et al." Then
      sXML &= "        <etal/>\n"
      Continue
    Endif

    ' BUSCAR COMA (formato BibTeX: Apellido, Nombre)
    posComa = InStr(nombreCompleto, ",")

    If posComa > 0 Then
      ' FORMATO: Apellido, Nombre
      apellido = TrimUTF8(Left(nombreCompleto, posComa - 1))
      nombre = TrimUTF8(Mid(nombreCompleto, posComa + 1))
    Else
      ' SIN COMA: asumir todo es apellido
      apellido = nombreCompleto
      nombre = ""
    Endif

    ' GENERAR <name>
    sXML &= "        <name>\n"
    sXML &= "          <surname>" & EscaparXML(apellido) & "</surname>\n"

    If Len(nombre) > 0 Then
      sXML &= "          <given-names>" & EscaparXML(nombre) & "</given-names>\n"
    Endif

    sXML &= "        </name>\n"
  Next

  sXML &= "      </person-group>\n"

  Return sXML

End Function

' =====================================================
' FUNCIÓN: LimpiarMarcasLatex
' DESCRIPCIÓN: LIMPIA MARCAS LATEX, CÓDIGOS HEXADECIMALES Y APLICA FORMATO XML
' =====================================================

Private Function LimpiarMarcasLatex(sTexto As String) As String

  Dim sResultado As String
  Dim comillaAbre As String
  Dim comillaCierra As String

  ' DEFINIR COMILLAS
  comillaAbre = Chr(34)
  comillaCierra = Chr(34)

  sResultado = sTexto

  ' ====================================================
  ' 1. PRIMERO ESCAPAR CARACTERES XML DEL TEXTO ORIGINAL
  ' ====================================================
  sResultado = Replace(sResultado, "&", "&amp;")
  sResultado = Replace(sResultado, "<", "&lt;")
  sResultado = Replace(sResultado, ">", "&gt;")

  ' ====================================================
  ' 2. MARCAS LATEX ESTÁNDAR (SINTAXIS BIBTEX)
  ' ====================================================

  ' ACENTOS AGUDOS
  sResultado = Replace(sResultado, "\\'{a}", "á")
  sResultado = Replace(sResultado, "\\'{e}", "é")
  sResultado = Replace(sResultado, "\\'{i}", "í")
  sResultado = Replace(sResultado, "\\'{o}", "ó")
  sResultado = Replace(sResultado, "\\'{u}", "ú")
  sResultado = Replace(sResultado, "\\'{A}", "Á")
  sResultado = Replace(sResultado, "\\'{E}", "É")
  sResultado = Replace(sResultado, "\\'{I}", "Í")
  sResultado = Replace(sResultado, "\\'{O}", "Ó")
  sResultado = Replace(sResultado, "\\'{U}", "Ú")

  ' ACENTOS GRAVES
  sResultado = Replace(sResultado, "\\`{a}", "à")
  sResultado = Replace(sResultado, "\\`{e}", "è")
  sResultado = Replace(sResultado, "\\`{i}", "ì")
  sResultado = Replace(sResultado, "\\`{o}", "ò")
  sResultado = Replace(sResultado, "\\`{u}", "ù")

  ' DIÉRESIS
  sResultado = Replace(sResultado, "\\\"{a}", "ä")
  sResultado = Replace(sResultado, "\\\"{e}", "ë")
  sResultado = Replace(sResultado, "\\\"{i}", "ï")
  sResultado = Replace(sResultado, "\\\"{o}", "ö")
  sResultado = Replace(sResultado, "\\\"{u}", "ü")
  sResultado = Replace(sResultado, "\\\"{y}", "ÿ")

  ' TILDE
  sResultado = Replace(sResultado, "\\~{n}", "ñ")
  sResultado = Replace(sResultado, "\\~{N}", "Ñ")
  sResultado = Replace(sResultado, "\\~{a}", "ã")
  sResultado = Replace(sResultado, "\\~{o}", "õ")

  ' CIRCUNFLEJO
  sResultado = Replace(sResultado, "\\^{a}", "â")
  sResultado = Replace(sResultado, "\\^{e}", "ê")
  sResultado = Replace(sResultado, "\\^{i}", "î")
  sResultado = Replace(sResultado, "\\^{o}", "ô")
  sResultado = Replace(sResultado, "\\^{u}", "û")

  ' CEDILLA
  sResultado = Replace(sResultado, "\\c{c}", "ç")
  sResultado = Replace(sResultado, "\\c{C}", "Ç")

  ' ====================================================
  ' 3. CARACTERES ESCAPADOS DE LATEX
  ' ====================================================
  sResultado = Replace(sResultado, "\\&", "&")
  sResultado = Replace(sResultado, "\\%", "%")
  sResultado = Replace(sResultado, "\\$", "$")
  sResultado = Replace(sResultado, "\\_", "_")
  sResultado = Replace(sResultado, "\\#", "#")
  sResultado = Replace(sResultado, "\\textasciitilde", "~")
  sResultado = Replace(sResultado, "\\textbackslash", "\\")

  ' ====================================================
  ' 4. ÉNFASIS E ITÁLICA → <italic> (AMBOS)
  '    ESTAS MARCAS SE INSERTAN **DESPUÉS** DE ESCAPAR XML
  ' ====================================================
  sResultado = ConvertirMarcaLatex(sResultado, "\\emph", "<italic>", "</italic>")
  sResultado = ConvertirMarcaLatex(sResultado, "\\textit", "<italic>", "</italic>")

  ' ====================================================
  ' 5. NEGRITA → <bold>
  ' ====================================================
  sResultado = ConvertirMarcaLatex(sResultado, "\\textbf", "<bold>", "</bold>")

  ' ====================================================
  ' 6. COMILLAS
  ' ====================================================
  sResultado = ConvertirMarcaLatex(sResultado, "\\enquote", comillaAbre, comillaCierra)

  ' ====================================================
  ' 7. GUIONES TIPOGRÁFICOS
  ' ====================================================
  sResultado = Replace(sResultado, "---", "—")  ' Guion largo (em dash)
  sResultado = Replace(sResultado, "--", "–")   ' Guion corto (en dash)

  ' ====================================================
  ' 8. ESPACIOS ESPECIALES
  ' ====================================================
  sResultado = Replace(sResultado, "~", " ")    ' Espacio no rompible LaTeX
  sResultado = Replace(sResultado, "\\ ", " ")  ' Espacio forzado LaTeX

  ' ====================================================
  ' 9. LIMPIAR LLAVES (al final, después de todo)
  ' ====================================================
  ' AUTORES CORPORATIVOS (llaves dobles)
  sResultado = Replace(sResultado, "{{", "")
  sResultado = Replace(sResultado, "}}", "")

  ' LLAVES SIMPLES RESTANTES
  sResultado = Replace(sResultado, "{", "")
  sResultado = Replace(sResultado, "}", "")

  Return sResultado

End Function

' =====================================================
' FUNCIÓN: ExportarJATSdesdeBIB
' DESCRIPCIÓN: EXPORTA REFERENCIAS BIBLIOGRÁFICAS A FORMATO XML-JATS
' RETORNA: Boolean - TRUE SI SE EXPORTÓ EXITOSAMENTE
' =====================================================

Public Function ExportarJATSdesdeBIB() As Boolean

  Dim sBibFile As String
  Dim sBibContent As String
  Dim sXML As String
  Dim outputFile As String
  Dim aEntries As String[]
  Dim sEntry As String
  Dim sCitekey As String
  Dim sType As String
  Dim iPosLlave As Integer
  Dim iPosComa As Integer
  Dim dictEntries As New Collection  ' DICCIONARIO PARA RESOLVER CROSSREF
  Dim dictTypes As New Collection    ' DICCIONARIO PARA TIPOS

  ' RUTA AL ARCHIVO BIB
  sBibFile = File.Dir(FMain.txtProyecto.Text) & "/referencias/ref-" & File.BaseName(FMain.txtProyecto.Text) & ".bib"

  ' VERIFICAR QUE EXISTE
  If Not Exist(sBibFile) Then
    Message.Error("El archivo .bib no existe. Exporte primero las referencias.")
    Return False
  Endif

  ' LEER CONTENIDO COMPLETO DEL BIB
  sBibContent = File.Load(sBibFile)

  ' ====================================================
  ' PRIMERA PASADA: ALMACENAR TODAS LAS ENTRADAS
  ' ====================================================

  aEntries = Split(sBibContent, "@", "", True)

  For Each sEntry In aEntries
    ' SALTAR ENTRADAS VACÍAS
    If TrimUTF8(sEntry) = "" Then Continue

    ' BUSCAR POSICIÓN DE { Y ,
    iPosLlave = InStr(sEntry, "{")
    iPosComa = InStr(sEntry, ",")

    ' VERIFICAR QUE EXISTEN
    If iPosLlave = 0 Or iPosComa = 0 Then Continue

    ' EXTRAER TIPO (sin la llave)
    sType = TrimUTF8(Left(sEntry, iPosLlave - 1))

    ' SALTAR @comment Y @string
    If Lower(sType) = "comment" Or Lower(sType) = "string" Then Continue

    ' EXTRAER CITEKEY
    sCitekey = TrimUTF8(Mid(sEntry, iPosLlave + 1, iPosComa - iPosLlave - 1))

    ' GUARDAR EN DICCIONARIOS
    dictEntries[sCitekey] = sEntry
    dictTypes[sCitekey] = sType
  Next

  ' ====================================================
  ' SEGUNDA PASADA: GENERAR XML RESOLVIENDO CROSSREF
  ' ====================================================

  ' INICIAR XML
  sXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
  sXML &= "<ref-list>\n"

  For Each sEntry In aEntries
    ' SALTAR ENTRADAS VACÍAS
    If TrimUTF8(sEntry) = "" Then Continue

    ' BUSCAR POSICIÓN DE { Y ,
    iPosLlave = InStr(sEntry, "{")
    iPosComa = InStr(sEntry, ",")

    ' VERIFICAR QUE EXISTEN
    If iPosLlave = 0 Or iPosComa = 0 Then Continue

    ' EXTRAER TIPO (sin la llave)
    sType = TrimUTF8(Left(sEntry, iPosLlave - 1))

    ' SALTAR @comment Y @string
    If Lower(sType) = "comment" Or Lower(sType) = "string" Then Continue

    ' EXTRAER CITEKEY
    sCitekey = TrimUTF8(Mid(sEntry, iPosLlave + 1, iPosComa - iPosLlave - 1))

    ' GENERAR ELEMENTO <ref>
    sXML &= "  <ref id=\"" & EscaparXML(sCitekey) & "\">\n"
    sXML &= GenerarElementCitationDesdeBib(sEntry, sType, dictEntries, dictTypes)
    sXML &= "  </ref>\n"
  Next

  ' CERRAR XML
  sXML &= "</ref-list>\n"

  ' GUARDAR ARCHIVO
  outputFile = File.Dir(FMain.txtProyecto.Text) & "/referencias/ref-" & File.BaseName(FMain.txtProyecto.Text) & ".xml"
  File.Save(outputFile, sXML)

  ' APLICAR REGLAS DE POSTPROCESO
  If Not AplicarReglasPostproceso(outputFile) Then
    Message.Error("Error en el postproceso del archivo XML")
    Return False
  Endif

  ' RETORNAR ÉXITO
  Return Exist(outputFile)

End

' =====================================================
' FUNCIÓN: GenerarElementCitationDesdeBib
' DESCRIPCIÓN: GENERA <element-citation> COMPLETO DESDE ENTRADA BIB
' PARÁMETROS:
'   - sEntry: TEXTO COMPLETO DE LA ENTRADA BIBTEX
'   - sType: TIPO DE ENTRADA (@article, @book, etc.)
'   - dictEntries: DICCIONARIO CON TODAS LAS ENTRADAS (para resolver crossref)
'   - dictTypes: DICCIONARIO CON TIPOS DE ENTRADAS
' RETORNA: STRING CON XML DE <element-citation>
' =====================================================

Private Function GenerarElementCitationDesdeBib(sEntry As String, sType As String, dictEntries As Collection, dictTypes As Collection) As String

  Dim sXML As String = ""
  Dim sPubType As String
  Dim sAuthor As String
  Dim sEditor As String
  Dim sEditorType As String
  Dim sEditorA As String
  Dim sEditorAType As String
  Dim sEditorB As String
  Dim sEditorBType As String
  Dim sEditorC As String
  Dim sEditorCType As String
  Dim sTranslator As String
  Dim sTitle As String
  Dim sSubtitle As String
  Dim sJournal As String
  Dim sBookTitle As String
  Dim sBookSubtitle As String
  Dim sYear As String
  Dim sDate As String
  Dim sVolume As String
  Dim sNumber As String
  Dim sPages As String
  Dim sPublisher As String
  Dim sAddress As String
  Dim sDoi As String
  Dim sIsbn As String
  Dim sIssn As String
  Dim sUrl As String
  Dim sEdition As String
  Dim sSchool As String
  Dim sInstitution As String
  Dim sNote As String
  Dim sEid As String
  Dim sEprint As String
  Dim sEprintType As String
  Dim sSeries As String
  Dim sVersion As String
  Dim sHolder As String
  Dim sMaintitle As String
  Dim sMainsubtitle As String
  Dim sBookauthor As String
  Dim aPages As String[]
  Dim sFinalYear As String
  Dim sTituloCompleto As String
  Dim sBookTitleCompleto As String
  Dim sCrossref As String
  Dim sEntryBase As String

  ' ====================================================
  ' 0. VERIFICAR SI HAY CROSSREF Y FUSIONAR ENTRADAS
  ' ====================================================

  sCrossref = ParsearCampoBib(sEntry, "crossref")

  If sCrossref <> "" And dictEntries.Exist(sCrossref) Then
    ' OBTENER ENTRADA BASE (la referenciada)
    sEntryBase = dictEntries[sCrossref]

    ' SI LA ENTRADA ACTUAL ES incollection, RENOMBRAR title→booktitle EN LA BASE
    If Lower(TrimUTF8(sType)) = "incollection" Then
      ' REEMPLAZAR "title =" por "booktitle =" en la entrada base
      sEntryBase = Replace(sEntryBase, "  title ", "  booktitle ", gb.IgnoreCase)
    Endif

    ' FUSIONAR: campos de sEntry tienen prioridad sobre sEntryBase
    sEntry = FusionarEntradas(sEntryBase, sEntry)
  Endif

  ' ====================================================
  ' 1. MAPEAR TIPO BIBTEX → JATS publication-type
  ' ====================================================

  Select Case Lower(TrimUTF8(sType))
    Case "article"
      sPubType = "journal"
    Case "book"
      sPubType = "book"
    Case "incollection", "inbook", "bookinbook", "collection"
      sPubType = "book"
    Case "phdthesis", "mastersthesis", "thesis"
      sPubType = "thesis"
    Case "misc", "online"
      sPubType = "web"
    Case "conference", "inproceedings"
      sPubType = "confproc"
    Case "report", "techreport"
      sPubType = "report"
    Case "patent"
      sPubType = "patent"
    Case "manual"
      sPubType = "book"
    Case "periodical"
      sPubType = "journal"
    Case Else
      sPubType = "other"
  End Select

  ' ====================================================
  ' 2. EXTRAER TODOS LOS CAMPOS DEL BIB
  ' ====================================================

  sAuthor = ParsearCampoBib(sEntry, "author")
  sEditor = ParsearCampoBib(sEntry, "editor")
  sEditorType = ParsearCampoBib(sEntry, "editortype")

  ' EDITORES ADICIONALES (BibLaTeX permite hasta editora, editorb, editorc)
  sEditorA = ParsearCampoBib(sEntry, "editora")
  sEditorAType = ParsearCampoBib(sEntry, "editoratype")
  sEditorB = ParsearCampoBib(sEntry, "editorb")
  sEditorBType = ParsearCampoBib(sEntry, "editorbtype")
  sEditorC = ParsearCampoBib(sEntry, "editorc")
  sEditorCType = ParsearCampoBib(sEntry, "editorctype")
  sTranslator = ParsearCampoBib(sEntry, "translator")
  sTitle = ParsearCampoBib(sEntry, "title")
  sSubtitle = ParsearCampoBib(sEntry, "subtitle")

  ' JOURNAL: PRIORIZAR journaltitle SOBRE journal
  sJournal = ParsearCampoBib(sEntry, "journaltitle")
  If sJournal = "" Then
    sJournal = ParsearCampoBib(sEntry, "journal")
  Endif

  sBookTitle = ParsearCampoBib(sEntry, "booktitle")
  sBookSubtitle = ParsearCampoBib(sEntry, "booksubtitle")

  ' ====================================================
  ' AÑO: PRIORIZAR date SOBRE year
  ' ====================================================
  sDate = ParsearCampoBib(sEntry, "date")
  sYear = ParsearCampoBib(sEntry, "year")

  If sDate <> "" Then
    sFinalYear = ExtraerAnio(sDate)
  Else If sYear <> "" Then
    sFinalYear = sYear
  Else
    sFinalYear = ""
  Endif

  sVolume = ParsearCampoBib(sEntry, "volume")
  sNumber = ParsearCampoBib(sEntry, "number")
  sPages = ParsearCampoBib(sEntry, "pages")
  sPublisher = ParsearCampoBib(sEntry, "publisher")

  ' LOCATION (BibLaTeX) o ADDRESS (BibTeX)
  sAddress = ParsearCampoBib(sEntry, "location")
  If sAddress = "" Then
    sAddress = ParsearCampoBib(sEntry, "address")
  Endif

  sDoi = ParsearCampoBib(sEntry, "doi")
  sIsbn = ParsearCampoBib(sEntry, "isbn")
  sIssn = ParsearCampoBib(sEntry, "issn")
  sUrl = ParsearCampoBib(sEntry, "url")
  sEdition = ParsearCampoBib(sEntry, "edition")

  ' ====================================================
  ' INSTITUCIÓN: BUSCAR school E institution
  ' ====================================================
  sSchool = ParsearCampoBib(sEntry, "school")
  sInstitution = ParsearCampoBib(sEntry, "institution")

  sNote = ParsearCampoBib(sEntry, "note")
  sEid = ParsearCampoBib(sEntry, "eid")

  ' ====================================================
  ' EPRINT (arXiv, etc.)
  ' ====================================================
  sEprint = ParsearCampoBib(sEntry, "eprint")
  sEprintType = ParsearCampoBib(sEntry, "eprinttype")

  ' ====================================================
  ' OTROS CAMPOS
  ' ====================================================
  sSeries = ParsearCampoBib(sEntry, "series")
  sVersion = ParsearCampoBib(sEntry, "version")
  sHolder = ParsearCampoBib(sEntry, "holder")
  sMaintitle = ParsearCampoBib(sEntry, "maintitle")
  sMainsubtitle = ParsearCampoBib(sEntry, "mainsubtitle")
  sBookauthor = ParsearCampoBib(sEntry, "bookauthor")

  ' ====================================================
  ' 3. INICIAR <element-citation>
  ' ====================================================

  sXML &= "    <element-citation publication-type=\"" & sPubType & "\">\n"

  ' ====================================================
  ' 4. PERSON-GROUP: AUTORES
  ' ====================================================

  If sAuthor <> "" Then
    sXML &= GenerarPersonGroup(sAuthor, "author")
  Endif

  ' ====================================================
  ' 5. PERSON-GROUP: EDITORES
  ' ====================================================

  If sEditor <> "" Then
    Dim sTipoEditor As String = MapearTipoEditor(sEditorType)
    sXML &= GenerarPersonGroup(sEditor, sTipoEditor)
  Endif

  ' EDITORES ADICIONALES (editora, editorb, editorc)
  If sEditorA <> "" Then
    Dim sTipoEditorA As String = MapearTipoEditor(sEditorAType)
    sXML &= GenerarPersonGroup(sEditorA, sTipoEditorA)
  Endif

  If sEditorB <> "" Then
    Dim sTipoEditorB As String = MapearTipoEditor(sEditorBType)
    sXML &= GenerarPersonGroup(sEditorB, sTipoEditorB)
  Endif

  If sEditorC <> "" Then
    Dim sTipoEditorC As String = MapearTipoEditor(sEditorCType)
    sXML &= GenerarPersonGroup(sEditorC, sTipoEditorC)
  Endif

  ' ====================================================
  ' 6. PERSON-GROUP: TRADUCTORES
  ' ====================================================

  If sTranslator <> "" Then
    sXML &= GenerarPersonGroup(sTranslator, "translator")
  Endif

  ' ====================================================
  ' 7. TÍTULOS
  ' ====================================================

  ' CONSTRUIR TÍTULO COMPLETO (title + subtitle si existe)
  If sSubtitle <> "" Then
    sTituloCompleto = sTitle & ": " & sSubtitle
  Else
    sTituloCompleto = sTitle
  Endif

  ' CONSTRUIR BOOKTITLE COMPLETO
  If sBookSubtitle <> "" Then
    sBookTitleCompleto = sBookTitle & ": " & sBookSubtitle
  Else
    sBookTitleCompleto = sBookTitle
  Endif

  ' DIFERENCIAR ENTRE LIBRO COMPLETO, CAPÍTULO Y ARTÍCULO
  If sBookTitleCompleto <> "" Then
    ' ES UN CAPÍTULO DE LIBRO O INCOLLECTION
    If sTituloCompleto <> "" Then
      sXML &= "      <chapter-title>" & sTituloCompleto & "</chapter-title>\n"
    Endif
    sXML &= "      <source>" & sBookTitleCompleto & "</source>\n"
  Else
    ' ES ARTÍCULO, LIBRO COMPLETO, TESIS O REPORTE
    If sTituloCompleto <> "" Then
      Select Case sPubType
        Case "journal"
          sXML &= "      <article-title>" & sTituloCompleto & "</article-title>\n"
        Case Else
          sXML &= "      <source>" & sTituloCompleto & "</source>\n"
      End Select
    Endif
  Endif

  ' ====================================================
  ' 8. FUENTE (REVISTA/JOURNAL)
  ' ====================================================

  If sJournal <> "" And sPubType = "journal" Then
    sXML &= "      <source>" & sJournal & "</source>\n"
  Endif

  ' ====================================================
  ' 9. SERIES (para books, incollection)
  ' ====================================================

  If sSeries <> "" And (sPubType = "book" Or InStr(Lower(sType), "collection") > 0) Then
    sXML &= "      <series>" & sSeries & "</series>\n"
  Endif

  ' ====================================================
  ' 10. PUBLICADOR Y UBICACIÓN
  ' ====================================================

  If sPublisher <> "" Then
    sXML &= "      <publisher-name>" & sPublisher & "</publisher-name>\n"
  Endif

  If sAddress <> "" Then
    sXML &= "      <publisher-loc>" & sAddress & "</publisher-loc>\n"
  Endif

  ' ====================================================
  ' 11. AÑO
  ' ====================================================

  If sFinalYear <> "" Then
    sXML &= "      <year>" & sFinalYear & "</year>\n"
  Endif

  ' ====================================================
  ' 12. VOLUMEN
  ' ====================================================

  If sVolume <> "" Then
    sXML &= "      <volume>" & sVolume & "</volume>\n"
  Endif

  ' ====================================================
  ' 13. NÚMERO (PATENT, REPORT, O ISSUE SEGÚN TIPO)
  ' ====================================================

  If sNumber <> "" Then
    Select Case sPubType
      Case "patent"
        ' PARA PATENTES: USAR <patent>
        sXML &= "      <patent>" & sNumber & "</patent>\n"

      Case "report"
        ' PARA REPORTES: USAR <pub-id pub-id-type="report-number">
        sXML &= "      <pub-id pub-id-type=\"report-number\">" & sNumber & "</pub-id>\n"

      Case Else
        ' PARA ARTÍCULOS Y OTROS: USAR <issue>
        sXML &= "      <issue>" & sNumber & "</issue>\n"
    End Select
  Endif

  ' ====================================================
  ' 14. PAGINACIÓN O EID
  ' ====================================================

  If sEid <> "" Then
    ' TIENE ELECTRONIC ID (artículos sin paginación tradicional)
    sXML &= "      <elocation-id>" & sEid & "</elocation-id>\n"
  Else If sPages <> "" Then
    ' TIENE PAGINACIÓN TRADICIONAL
    ' DIVIDIR: "123-145" o "123--145"
    If InStr(sPages, "--") > 0 Then
      aPages = Split(sPages, "--")
    Else If InStr(sPages, "-") > 0 Then
      aPages = Split(sPages, "-")
    Else
      ' SOLO UNA PÁGINA
      sXML &= "      <fpage>" & TrimUTF8(sPages) & "</fpage>\n"
      sXML &= "      <lpage>" & TrimUTF8(sPages) & "</lpage>\n"
      aPages = Null
    Endif

    ' SI HAY RANGO DE PÁGINAS
    If aPages Then
      If aPages.Count >= 2 Then
        sXML &= "      <fpage>" & TrimUTF8(aPages[0]) & "</fpage>\n"
        sXML &= "      <lpage>" & TrimUTF8(aPages[1]) & "</lpage>\n"
      Else If aPages.Count = 1 Then
        sXML &= "      <fpage>" & TrimUTF8(aPages[0]) & "</fpage>\n"
        sXML &= "      <lpage>" & TrimUTF8(aPages[0]) & "</lpage>\n"
      Endif
    Endif
  Endif

  ' ====================================================
  ' 15. EDICIÓN
  ' ====================================================

  If sEdition <> "" Then
    sXML &= "      <edition>" & sEdition & "</edition>\n"
  Endif

  ' ====================================================
  ' 16. INSTITUCIÓN (TESIS Y REPORTES)
  ' ====================================================

  If sPubType = "thesis" Or sPubType = "report" Then
    ' PRIORIZAR institution (BibLaTeX) sobre school (BibTeX)
    If sInstitution <> "" Then
      sXML &= "      <institution>" & sInstitution & "</institution>\n"
    Else If sSchool <> "" Then
      sXML &= "      <institution>" & sSchool & "</institution>\n"
    Endif
  Endif

  ' ====================================================
  ' 17. NOTA/COMENTARIO
  ' ====================================================

  If sNote <> "" Then
    sXML &= "      <comment>" & sNote & "</comment>\n"
  Endif

  ' ====================================================
  ' 18. VERSION (para online)
  ' ====================================================

  If sVersion <> "" And sPubType = "web" Then
    sXML &= "      <comment>Version " & sVersion & "</comment>\n"
  Endif

  ' ====================================================
  ' 19. HOLDER (para patents)
  ' LIMPIAR LLAVES DOBLES Y CONVERTIR
  ' ====================================================

  If sHolder <> "" And sPubType = "patent" Then
    ' LIMPIAR LLAVES DOBLES DE AUTORES CORPORATIVOS
    Dim sHolderLimpio As String
    sHolderLimpio = Replace(sHolder, "{{", "")
    sHolderLimpio = Replace(sHolderLimpio, "}}", "")
    sHolderLimpio = Replace(sHolderLimpio, "{", "")
    sHolderLimpio = Replace(sHolderLimpio, "}", "")

    ' CONVERTIR "and" EN COMAS PARA MEJOR LEGIBILIDAD
    sHolderLimpio = Replace(sHolderLimpio, " and ", ", ")

    sXML &= "      <comment>Patent holder: " & sHolderLimpio & "</comment>\n"
  Endif

  ' ====================================================
  ' 20. IDENTIFICADORES: ISBN, ISSN, DOI
  ' ====================================================

  If sIsbn <> "" Then
    sXML &= "      <isbn>" & sIsbn & "</isbn>\n"
  Endif

  If sIssn <> "" Then
    sXML &= "      <issn>" & sIssn & "</issn>\n"
  Endif

  If sDoi <> "" Then
    sXML &= "      <pub-id pub-id-type=\"doi\">" & sDoi & "</pub-id>\n"
  Endif

  ' ====================================================
  ' 21. EPRINT (arXiv, etc.)
  ' ====================================================

  If sEprint <> "" Then

    If sEprintType <> "" Then
      sEprintType = Lower(sEprintType)
    Endif

    sXML &= "      <pub-id pub-id-type=\"" & sEprintType & "\">" & sEprint & "</pub-id>\n"
  Endif

  ' ====================================================
  ' 22. URL
  ' ====================================================

  If sUrl <> "" Then
    sXML &= "      <ext-link ext-link-type=\"uri\" xlink:href=\"" & sUrl & "\">" & sUrl & "</ext-link>\n"
  Endif

  ' ====================================================
  ' 23. CERRAR </element-citation>
  ' ====================================================

  sXML &= "    </element-citation>\n"

  Return sXML

End

' =====================================================
' FUNCIÓN: ParsearCampoBib
' DESCRIPCIÓN: EXTRAE VALOR DE UN CAMPO DEL BIB SIN LIMPIAR
' PARÁMETROS:
'   - sEntry: TEXTO COMPLETO DE LA ENTRADA BIBTEX
'   - sCampo: NOMBRE DEL CAMPO A EXTRAER (author, title, etc.)
' RETORNA: String - VALOR DEL CAMPO (vacío si no existe)
' =====================================================

Private Function ParsearCampoBib(sEntry As String, sCampo As String) As String

  Dim iStart As Integer
  Dim iEnd As Integer
  Dim sValor As String = ""
  Dim sPatron As String

  ' PATRÓN 1: campo = {valor}
  sPatron = sCampo & " = {"
  iStart = InStr(sEntry, sPatron)

  ' PATRÓN 2: campo={valor}
  If iStart = 0 Then
    sPatron = sCampo & "={"
    iStart = InStr(sEntry, sPatron)
  Endif

  ' PATRÓN 3: BUSCAR POR LÍNEAS
  If iStart = 0 Then
    Dim aLineas As String[] = Split(sEntry, "\n")
    Dim sLinea As String

    For Each sLinea In aLineas
      sLinea = TrimUTF8(sLinea)

      If Left(sLinea, Len(sCampo)) = sCampo Then
        iStart = InStr(sLinea, "{")
        If iStart > 0 Then
          ' ============================================
          ' ✅ USAR EncontrarLlaveCorrespondiente()
          ' ============================================
          iEnd = EncontrarLlaveCorrespondiente(sLinea, iStart + 1)
          If iEnd > 0 Then
            sValor = Mid(sLinea, iStart + 1, iEnd - iStart - 1)
            Return TrimUTF8(sValor)
          Endif
        Endif
      Endif
    Next

    Return ""
  Endif

  ' POSICIÓN INICIAL DEL VALOR (después de la llave {)
  iStart = iStart + Len(sPatron)

  ' ============================================
  ' ✅ BUSCAR CIERRE CON LLAVES ANIDADAS
  ' ============================================
  iEnd = EncontrarLlaveCorrespondiente(sEntry, iStart)

  If iEnd = 0 Then Return ""

  ' EXTRAER VALOR
  sValor = Mid(sEntry, iStart, iEnd - iStart)

  Return TrimUTF8(sValor)

End

' =====================================================
' FUNCIÓN: FusionarEntradas
' DESCRIPCIÓN: FUSIONA DOS ENTRADAS BIB (para resolver crossref)
' PARÁMETROS:
'   - sEntryBase: ENTRADA BASE (referenciada por crossref)
'   - sEntryActual: ENTRADA ACTUAL (tiene prioridad)
' RETORNA: String - ENTRADA FUSIONADA
' =====================================================

Private Function FusionarEntradas(sEntryBase As String, sEntryActual As String) As String

  Dim aLineasBase As String[]
  Dim aLineasActual As String[]
  Dim dictCampos As New Collection
  Dim sLinea As String
  Dim sCampo As String
  Dim iPosIgual As Integer
  Dim sResultado As String
  Dim sPrimeraLinea As String
  Dim i As Integer

  ' ====================================================
  ' PARSEAR ENTRADA BASE Y ALMACENAR CAMPOS
  ' ====================================================

  aLineasBase = Split(sEntryBase, "\n")

  For i = 0 To aLineasBase.Max
    sLinea = aLineasBase[i]

    ' SALTAR LÍNEAS VACÍAS
    If Len(Trim(sLinea)) = 0 Then Continue

    ' SALTAR LÍNEA QUE CIERRA LA ENTRADA (})
    If Trim(sLinea) = "}" Then Continue

    ' BUSCAR = EN LA LÍNEA
    iPosIgual = InStr(sLinea, "=")

    ' SI NO HAY =, NO ES UN CAMPO VÁLIDO
    If iPosIgual = 0 Then Continue

    ' EXTRAER NOMBRE DEL CAMPO (todo antes del =, sin espacios)
    sCampo = Trim(Left(sLinea, iPosIgual - 1))

    ' IGNORAR SI ES LA PRIMERA LÍNEA
    If InStr(sCampo, "{") > 0 Then Continue

    ' CONVERTIR A MINÚSCULAS
    sCampo = Lower(sCampo)

    ' GUARDAR LÍNEA COMPLETA
    dictCampos[sCampo] = sLinea
  Next

  ' ====================================================
  ' PARSEAR ENTRADA ACTUAL Y SOBRESCRIBIR
  ' ====================================================

  aLineasActual = Split(sEntryActual, "\n")

  ' GUARDAR LA PRIMERA LÍNEA
  sPrimeraLinea = aLineasActual[0]

  For i = 0 To aLineasActual.Max
    sLinea = aLineasActual[i]

    ' SALTAR LÍNEAS VACÍAS
    If Len(Trim(sLinea)) = 0 Then Continue

    ' SALTAR LÍNEA QUE CIERRA LA ENTRADA
    If Trim(sLinea) = "}" Then Continue

    ' BUSCAR = EN LA LÍNEA
    iPosIgual = InStr(sLinea, "=")

    ' SI NO HAY =, NO ES UN CAMPO VÁLIDO
    If iPosIgual = 0 Then Continue

    ' EXTRAER NOMBRE DEL CAMPO
    sCampo = Trim(Left(sLinea, iPosIgual - 1))

    ' IGNORAR SI ES LA PRIMERA LÍNEA
    If InStr(sCampo, "{") > 0 Then Continue

    ' CONVERTIR A MINÚSCULAS
    sCampo = Lower(sCampo)

    ' NO COPIAR crossref
    If sCampo = "crossref" Then
      Continue
    Endif

    ' SOBRESCRIBIR
    dictCampos[sCampo] = sLinea
  Next

  ' ====================================================
  ' RECONSTRUIR ENTRADA
  ' ====================================================

  sResultado = sPrimeraLinea & "\n"

  ' ITERAR SOBRE LAS KEYS, NO SOBRE LA COLECCIÓN DIRECTAMENTE
  Dim aKeys As String[] = dictCampos.Keys

  For i = 0 To aKeys.Max
    sCampo = aKeys[i]
    sResultado &= dictCampos[sCampo] & "\n"
  Next

  sResultado &= "}\n"

  Return sResultado

End

' =====================================================
' FUNCIÓN: AplicarReglasPostproceso
' =====================================================
' DESCRIPCIÓN:
'   Ejecuta el script de postproceso Python/Perl sobre
'   el archivo XML exportado
'
' PARÁMETROS:
'   sXmlFile: Ruta completa al archivo XML a procesar
'
' RETORNA:
'   True si el postproceso fue exitoso
'   False si hubo algún error
' =====================================================

Public Function AplicarReglasPostproceso(sXmlFile As String) As Boolean

  Dim sScriptPython As String
  Dim sComando As String

  ' VERIFICAR QUE EL ARCHIVO XML EXISTE
  If Not Exist(sXmlFile) Then
    Message.Error("El archivo XML no existe: " & sXmlFile)
    Return False
  Endif

  ' UBICACIÓN DEL SCRIPT PYTHON
  sScriptPython = User.Home &/ ".gbpublisher/postprocesar_jats.py"

  ' VERIFICAR QUE EL SCRIPT EXISTE
  If Not Exist(sScriptPython) Then
    Message.Warning("No se encontró el script de postproceso: " & sScriptPython & "\nNo se aplicará postproceso.")
    Return True
  Endif

  ' CONSTRUIR COMANDO
  sComando = "python3 '" & sScriptPython & "' '" & sXmlFile & "'" & "\n"

  ' EJECUTAR EN EL TERMINAL INTEGRADO
  FMain.TerminalViewProyecto.Input(sComando)
  Wait 0.5
  FMain.TerminalViewProyecto.Input("clear" & "\n")

  Return True

Catch
  Message.Error("Error en postproceso:\n" & Error.Text)
  Return False

End Function

' =====================================================
' FUNCIÓN: TrimUTF8
' =====================================================
' DESCRIPCIÓN:
'   Elimina espacios ASCII (0x20) al inicio y final de
'   una cadena SIN corromper caracteres UTF-8 multibyte
'
' PROBLEMA QUE RESUELVE:
'   Trim() de Gambas elimina bytes 0xA0 que son parte
'   de secuencias UTF-8 válidas (como à = 0xC3 0xA0)
'
' PARÁMETROS:
'   sTexto: Cadena a procesar
'
' RETORNA:
'   Cadena sin espacios ASCII al inicio/final
' =====================================================

Public Function TrimUTF8(sTexto As String) As String

  Dim iStart As Integer
  Dim iEnd As Integer
  Dim iByte As Integer

  If Not sTexto Then Return ""

  iStart = 1
  iEnd = Len(sTexto)

  ' ELIMINAR ESPACIOS ASCII (0x20) AL INICIO
  While iStart <= iEnd
    iByte = Asc(Mid(sTexto, iStart, 1))
    If iByte <> 32 Then Break  ' 32 = 0x20 = espacio ASCII
    iStart += 1
  Wend

  ' ELIMINAR ESPACIOS ASCII (0x20) AL FINAL
  While iEnd >= iStart
    iByte = Asc(Mid(sTexto, iEnd, 1))
    If iByte <> 32 Then Break
    iEnd -= 1
  Wend

  ' RETORNAR SUBSTRING SIN ESPACIOS
  If iStart > iEnd Then
    Return ""
  Else
    Return Mid(sTexto, iStart, iEnd - iStart + 1)
  Endif

End Function

' =====================================================
' FUNCIÓN AUXILIAR: MapearTipoEditor
' DESCRIPCIÓN: MAPEA TIPOS DE EDITOR BIBLATEX A JATS
' PARÁMETROS: sTipoBibLaTeX - TIPO DE EDITOR EN BIBLATEX
' RETORNA: String - TIPO DE PERSON-GROUP EN JATS
' =====================================================

Private Function MapearTipoEditor(sTipoBibLaTeX As String) As String

  Dim sTipo As String

  If sTipoBibLaTeX = "" Then
    Return "editor"  ' DEFAULT
  Endif

  ' MAPEAR TIPOS BIBLATEX → JATS
  Select Case Lower(sTipoBibLaTeX)
    Case "editor"
      sTipo = "editor"
    Case "compiler"
      sTipo = "compiler"
    Case "founder"
      sTipo = "editor"        ' JATS no tiene founder específico
    Case "continuator"
      sTipo = "editor"        ' JATS no tiene continuator específico
    Case "redactor"
      sTipo = "editor"        ' JATS no tiene redactor específico
    Case "reviser", "reviewer"
      sTipo = "editor"        ' JATS no tiene reviser específico
    Case "collaborator"
      sTipo = "editor"        ' JATS no tiene collaborator específico
    Case "organizer"
      sTipo = "editor"        ' Para conferencias
    Case "translator"
      sTipo = "translator"
    Case Else
      sTipo = "editor"        ' DEFAULT para tipos desconocidos
  End Select

  Return sTipo

End
